Questions

Original TripService 에서 개선이 필요한 점들을 기술하세요.
    1) Tell, don't ask
        친구관계인지 확인하는 기능을 TripService가 하지 말고, User 객체에 요청해야 한다.
        user.gerFriends() 대신 user.isFriend(loggedUser) 등을 사용해야 함
    2) 비즈니스 로직에서 유저 세션에 의존하고 있다.

레거시 코드에 테스트를 작성할 때에 인덴트가 얕은 부분부터 작성하는 이유는 무엇인가요?
    가장 깊은 부분에 대해 테스트를 작성하려면 모든 코드에 대해 다 이해하고 있어야만 가능하다.
    (모든 가능한 케이스에 대한 테스트 데이터가 다 도출되어야만 한다.)
    하지만 레거시 코드에 대한 이해를 하면서 동시에 테스트를 작성해 가는 게 맞다.
    얕은 부분부터 작성해 나가면서 동시에 점진적으로 제품코드를 이해해 갈 수 있고,
    그렇게 테스트를 작성해 나가면 모양도 좋아진다.

리팩토링 할 때에 코드의 인덴트가 깊은 부분부터 하는 이유는 무엇인가요?
    글로벌 변수가 많고, 변수의 세팅도 여러 군데서 진행하며, 의존관계도 복잡하다.
    가장 인덴트가 깊은 곳이 다른 곳에 의존하지 않기 때문이다.

레거시 코드에 단위 테스트를 작성하기 어려운 이유는 어떤 것들이 있을까요?
    1) 레거시 코드를 100% 이해하지 못하기 때문에.
        테스트를 작성한다는 의미는 테스트 데이터도 다 만들어서 해당 데이터로 작성하는데
        기존 코드를 이해하지 못한 상태에서 테스트 데이터를 다 만들어놓을 순 없다.
    2) 레거시 코드가 클린하지 않다.
        의존관계가 명확하지 않은 경우, 테스트 데이터를 만들기 힘들고, mocking 하기 어렵다


단위테스트에서 DAO를 직접 호출하지 않는 이유는 어떤 것들이 있을까요?
    단위테스트이기 때문이다.
    DAO는 비즈니스 로직이 아니라 호출 대상이며, 테스트 대상의 범위에 들어가지 않는다.
    만약 DAO의 로직을 테스트하고 싶다면 DAO를 위한 테스트를 별도로 작성해야 한다.
    하지만 DAO의 역할이 DB에서 데이터를 읽어오거나 저장하는 기능만 담당해야 하므로
    DAO에 비즈니스 로직이 있다면 그 것 또한 문제가 된다.


시연 중에 코드 커버리지 툴은 어떤 용도로 사용되고 있나요?
    1) 다음 인덴트를 알 수 있다.(테스트 작성 대상을 알 수 있다.)
    2) 레거시 코드 분석에도 도움이 된다.

시연 중에 변경 범위가 큰 위험한 리팩토링을 한 이유는 무엇일까요? (50:20~57:04)
    기존 레거시 코드의 디자인이 잘못 되었기 때문이다.
    (비즈니스 로직에서 유저 세션에 의존하고 있다.)
    따라서 레거시 코드의 디자인을 변경해야만 하고,
    작성된 테스트까지 모두 재작성해야만 하는 위험을 동반한다.

시연에서 사용된 단위 테스트의 명명 규칙에 대해 기술하세요
    소문자로 작성하며, 단어 사이에 _를 추가한다.
    should_xxx_when_xxx(_then_xxx) 의 구조를 가지고 있다.

클린 코드는 “잘 작성된 산문”과 같은 코드라고도 말합니다. 시연에서 잘 작성된 산문과 같은 코드의 사례를 찾아서 기술하세요.
    단위테스트의 메소드와 실제 코드가 산문과 같이 읽히는 것이 매우 보람된 것 같습니다.

    should_throw_an_exception_when_user_is_not_logged_in    // 로그인하지 않았으면 throw
    should_not_return_any_trips_when_users_are_not_friends  // 친구가 아니면 여행정보가 존재하지 않음
    should_return_friend_trips_when_users_are_friends       // 친구가 맞다면 여행정보를 가져온

    public List<Trip> getFriendTrips(User friend, User loggedInUser) throws UserNotLoggedInException {
            validate(loggedInUser);                         // 로그인하지 않았으면 throw

            return friend.isFriendWith(loggedInUser)
                    ? tripsBy(friend)                       // 친구가 맞다면 여행정보를 가져온
                    : noTrips();                            // 친구가 아니면 여행정보가 존재하지 않음
        }

